
#include "exptype.h"

piece  base, turret, barrel1, flare1, barrel2, flare2, barrel3, flare3, sleeve, foreturret, foregun, foreflare, aftturret, aftgun, aftflare, ground, wake, bow;

static-var  gun_1, restore_delay, gun_2, Static_Var_7, Static_Var_8, aimDir, oldHead;

// Signal definitions
#define SIGNAL_AIM2 512
#define SIGNAL_AIM1 256
#define SIGNAL_MOVE 1

#define BASEPIECE base
#define HITSPEED <20.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 200

//#include "unit_hitbyweaponid_and_smoke.h"



// -------------------------------- WARSHIP ------------------------
// TODO:
// [ ] Make damping factor scale with current pitch and roll
// [ ] Fix rounding of angular acceleration at <1.0

// [ ] Rock when slow, do this by modulating the 'target pos' 
// [ ] pitch forward when moving fast
// [ ] bank when turning 
// [ ] Damping as a better var


// REQUIRED STATIC VARS:
// heading


//-------------------- EXTERNAL DEFINES ------------------
// mass of boat in AU
#define RB_MASS 50

//Virtual Length and width of boat in elmos, assume the boat is a tall as it is wide
#define RB_LENGTH 8
#define RB_WIDTH 3

#define RB_RECOIL_FORCE 10
#define RB_PIECE ground

// where 100 is no damping.
#define RB_DAMPING 95

// How often should the speed/position of the boat be adjusted
// 1: 1.8% CPU/1k, for flagships only
// 2: 1.1% CPU/1k  for smaller boats
// 3: 0.8% CPU/1k  if you really wanna save a tiny bit of perf

#define RB_FRAMES 2

// ------------------ INTERNAL DEFINES ------------------

#define RB_INERTIA_PITCH ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_LENGTH * RB_LENGTH) / (120/ RB_FRAMES)) ;
#define RB_INERTIA_ROLL  ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_WIDTH  * RB_WIDTH ) / (120/ RB_FRAMES)) ;
#define SIGN(v) ((v > 0) - (v < 0)) 
#define ABS(v) (v * (-1 * (v<0)))

// Pitch is the X axis
// Roll is the Z axis
static-var RB_pitch, RB_roll;
static-var RB_pitch_velocity, RB_roll_velocity;

InitRockBoat(){
	//RB_inertia_pitch = (RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_LENGTH * RB_LENGTH) /120 ; // X axis
	//RB_inertia_roll  = (RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_WIDTH * RB_WIDTH) /120 ;   // Z axis
	RB_pitch = 0;
	RB_roll = 0;
	RB_pitch_velocity = 0;
	RB_roll_velocity = 0;
	
	turn RB_PIECE to x-axis RB_pitch now;
	turn RB_PIECE to z-axis RB_roll  now;

	var torque_pitch;
	torque_pitch = 0;
	var torque_roll;
	torque_roll = 0;
	

	var dbg1;
	dbg1 = 0;
	var gf;
	gf = 0;
	gf = !(!RB_pitch) + !(RB_PITCH && 0x800000);
	var sign;
	sign = 1;
	
	sign = (RB_pitch >0) - (RB_pitch<0);
	sign = SIGN(RB_pitch);
	// MAX:
	
	var mymax;

	torque_pitch = (torque_pitch > 100) * 100 + (torque_pitch <= 100) * torque_pitch;
	
	
	//return (0);
	while (1){
		// Calculate restoring torque due to displacement
		torque_pitch = ( RB_pitch * (-1 *  RB_FRAMES))/10;
		torque_roll =  ( RB_roll  * (-1 *  RB_FRAMES))/10;
		
		//silly max without jump
		//torque_pitch = (torque_pitch > 100) * 100 + (torque_pitch <= 100) * torque_pitch;
		//if (torque_pitch > 100) torque_pitch = 100;
		//if (torque_roll > 100)   torque_roll = 100;
		//if (torque_pitch < -100) torque_pitch = -100;
		//if (torque_roll < -100)   torque_roll = -100;
		
		
		// Print debugging stuff:
		//get PRINT(88888, torque_pitch, torque_roll);

		// Convert torque to angular acceleration 
		//RB_angular_acceleration_pitch = (   torque_pitch) / RB_INERTIA_PITCH;
		//RB_angular_acceleration_roll  = (   torque_roll ) / RB_INERTIA_ROLL ;

		// Update angular velocity with angular acceleration
		RB_pitch_velocity = RB_pitch_velocity + (torque_pitch) / RB_INERTIA_PITCH ;
		RB_roll_velocity  = RB_roll_velocity  + (torque_roll ) / RB_INERTIA_ROLL   ;
		
		// Simple damping to simulate resistance from water and air
		RB_pitch_velocity = ((  RB_pitch_velocity * RB_DAMPING) / 100) ;
		RB_roll_velocity  = ((  RB_roll_velocity  * RB_DAMPING) / 100) ;
		
		if (RB_pitch_velocity == 0) {
			if (RB_pitch > 0) RB_pitch_velocity = -1;
			else RB_pitch_velocity = 1;
		}
		
		
		if (RB_roll_velocity == 0) {
			if (RB_roll > 0) RB_roll_velocity = -1;
			else RB_roll_velocity = 1;
		}
		
		//RB_pitch_velocity = RB_pitch_velocity + 

		// Print debugging stuff:
		//get PRINT(RB_roll_velocity, RB_roll_velocity, RB_angular_acceleration_pitch, RB_angular_acceleration_roll);
		
		// Update pitch and roll based on angular velocity
		RB_pitch = RB_pitch + RB_pitch_velocity ;
		RB_roll  = RB_roll  + RB_roll_velocity;

		// Print debugging stuff:
		//get PRINT(RB_pitch, RB_roll, RB_pitch_velocity, RB_roll_velocity);

		// Execute corresponding movements
		//if (RB_FRAMES == 1){
		//turn RB_PIECE to x-axis RB_pitch now; 
		//turn RB_PIECE to z-axis RB_roll now; 
		
		//}else{
		
			turn RB_PIECE to x-axis RB_pitch speed (30 / RB_FRAMES) * RB_pitch_velocity;
			turn RB_PIECE to z-axis RB_roll  speed (30 / RB_FRAMES) * RB_roll_velocity;
		
		//}
		
		sleep 32 * RB_FRAMES;

	}
}


RockOnWaves()
{
	var currHeading, currSpeed, prevHeading, prevSpeed;	
	while( TRUE )
	{
		currHeading = get (HEADING);
		currSpeed =   get (MAX_SPEED);
		sleep 1000;
	}
}

// Pass in the pitch and heading of the current aiming here 
// heading: 0 is forward, 16K is 90deg left, -16K is 90 deg right

RecoilRockBoat(heading, power){
	// Separate heading into X and Z axes
	
	// Where RockZComponent is +1024 on the heading = left
	var RockZComponent;
	RockZComponent = get KSIN(heading);
	
	// Where RockXComponent is +1024 when aiming forward. 
	var RockXComponent;
	RockXComponent = get KCOS(heading);
	//get PRINT (heading,power, RockXComponent, RockZComponent);
	
	// Add with negative sign as we want it to move backwards from heading;
	RB_pitch_velocity = RB_pitch_velocity - RockXComponent / 4 ;
	RB_roll_velocity  = RB_roll_velocity  - RockZComponent / 4;

}



// anglez is left-right, +500 right
// anglex is front-back, where +500 is front

// only called if HitByWeaponId NOT defined
//HitByWeapon(anglex, anglez, damage)	// angle[x|z] is always [-500;500], damage is multiplied by 100
//{
//	get PRINT(-1000, anglex, anglez, damage);	
//}

// If HitByWeaponId is defined, then HitByWeapon is not called 
// anglez is left-right, +500 right
// anglex is front-back, where +500 is front
HitByWeaponId(anglex, anglez, weaponid, dmg) //weaponID is always 0,lasers and flamers give angles of 0
{
	//get PRINT(anglex, anglez, weaponid, dmg);
	RB_pitch_velocity = RB_pitch_velocity - anglex / 4 ;
	RB_roll_velocity  = RB_roll_velocity  + anglez / 4;
	// always return damage percent!
	return (100); 
}

// -------------------------------- END WARSHIP --------------------

SetDirection(windHeading, windStrength)
{
//	var spd;
//	spd = (get ABS(oldHead) - get ABS(heading)) / 2;
//	turn ground to y-axis heading speed spd;
//	turn base to y-axis 0-heading speed spd;
//	oldHead = heading;
	//RB_pitch_velocity = RB_pitch_velocity - RockXComponent / 4 ;
	//RB_roll_velocity  = RB_roll_velocity  - RockZComponent / 4;

}
/*
RockOnWaves()
{
	var rockDir, rockAng, rockSpeed;
	rockDir = <-0.1>;
	rockAng = <-0.1>;
	while( TRUE )
	{
		while( get ABS(rockAng) < <1.31> )
		{
			rockSpeed = <1.45> - get ABS(rockAng);
		//	turn ground to x-axis rockAng speed rockSpeed*4;
		//	wait-for-turn ground around x-axis;
			rockAng = rockAng + rockDir;
			sleep 1;
		}
		rockDir = 0 - rockDir;
		rockAng = rockAng + rockDir + rockDir;
	}
}*/

Create()
{
	hide bow;
	hide wake;
	hide flare2;
	hide flare3;
	hide flare1;
	hide aftflare;
	hide foreflare;
	hide ground;
	hide flare1;
	hide flare2;
	hide foreflare;
	hide aftflare;
	gun_1 = base;
	gun_2 = base;
	restore_delay = 3000;
	while( get BUILD_PERCENT_LEFT )
	{
		sleep 500;
	}
	start-script RockOnWaves();
	start-script InitRockBoat();
}

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	set-signal-mask 0;
	turn turret to y-axis <0.000000> speed <55.000000>;
	turn barrel1 to x-axis <0.000000> speed <15.000000>;
	turn barrel2 to x-axis <0.000000> speed <15.000000>;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

RestoreDeckLaser()
{
	sleep 3000;
	set-signal-mask 0;
	turn foreturret to y-axis <0.000000> speed <150.000000>;
	turn foregun to x-axis <0.000000> speed <100.000000>;
	turn aftturret to y-axis <0.000000> speed <150.000000>;
	turn aftgun to x-axis <0.000000> speed <100.000000>;
}

waveSplash()
{
	return (0);
	while( TRUE )
	{
		turn base to x-axis <-3.0> speed <3.0>;
		move base to y-axis [0.32] speed [0.25];
		wait-for-turn base around x-axis;
		turn base to x-axis <0.0> speed <3.0>;
		move base to y-axis [0.0] speed [0.25];
		wait-for-turn base around x-axis;
	}
}

StartMoving()
{
	signal SIGNAL_MOVE;
	set-signal-mask SIGNAL_MOVE;
	var waketime;
	start-script waveSplash();
	var bowtime;
	bowtime = 0;
	while( TRUE )
	{
		emit-sfx 1024 + 1 from wake;
		if (bowtime) emit-sfx 1024 + 2 from bow;
        bowtime = !bowtime;
		waketime = (get CURRENT_SPEED) * 100 / get MAX_SPEED;
		if( waketime < 50 ) waketime = 50;
		sleep 10000 / waketime;
	}
}

StopMoving()
{
	signal SIGNAL_MOVE;
	turn base to x-axis <0.0> speed <3.0>;
	move base to y-axis [0.0] speed [0.25];
}

AimWeapon2(heading, pitch)
{
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;
	if( gun_2 )
	{
		turn aftturret to y-axis heading speed <300.000000>;
		turn aftgun to x-axis <0.000000> - pitch speed <200.000000>;
		wait-for-turn aftturret around y-axis;
		wait-for-turn aftgun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
	else
	{
		turn foreturret to y-axis heading speed <300.000000>;
		turn foregun to x-axis <0.000000> - pitch speed <200.000000>;
		wait-for-turn foreturret around y-axis;
		wait-for-turn foregun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
}

FireWeapon2()
{
	//call-script RecoilRockBoat()
	if( gun_2 )
	{
		show aftflare;
		sleep 150;
		hide aftflare;
	}
	else
	{
		show foreflare;
		sleep 150;
		hide foreflare;
	}
	gun_2 = !gun_2;
}

AimFromWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftgun;
	}
	else
	{
		pieceIndex = foregun;
	}
}

QueryWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftflare;
	}
	else
	{
		pieceIndex = foreflare;
	}
}

AimWeapon3(heading, pitch)
{
	return (1);
}

FireWeapon3()
{
	sleep 150;
}

AimFromWeapon3(pieceIndex)
{
	pieceIndex = base;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = base;
}

AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;
	turn turret to y-axis heading speed <110.000000>;
	turn sleeve to x-axis <0.000000> - pitch speed <90.000000>;
	wait-for-turn turret around y-axis;
	wait-for-turn sleeve around x-axis;
	aimDir = heading;
	start-script RestoreAfterDelay();
	return (1);
}

FireWeapon1()
{
	//start-script RockZ(-7, aimDir);
	if( gun_1 ==0)
	{
	    emit-sfx 1024 + 0 from flare1;
		move barrel1 to z-axis [-2.300000] now;
		move barrel1 to z-axis [0.000000] speed [1.500000];
	}
	else if (gun_1==1)
	{
	    emit-sfx 1024 + 0 from flare2;
		move barrel2 to z-axis [-2.300000] now;
		move barrel2 to z-axis [0.000000] speed [1.500000];
	}else
	{
	    emit-sfx 1024 + 0 from flare3;
		move barrel3 to z-axis [-2.300000] now;
		move barrel3 to z-axis [0.000000] speed [1.500000];
	}
	gun_1=gun_1+1;
	if (gun_1>2){
		gun_1=0;
	}
	
	// A bit of delay before adding velocity looks way better :D
	//#IF RB_FRAMES == 1
	//	sleep 65;
	//#ENDIF
	call-script RecoilRockBoat(aimDir, 100);
}

AimFromWeapon1(pieceIndex)
{
	pieceIndex = turret;
}

QueryWeapon1(pieceIndex)
{
	if( gun_1 ==0)
	{
		pieceIndex = flare1;
	}
	else if( gun_1 ==1)
	{
		pieceIndex = flare2;
	}
	else
	{
		pieceIndex = flare3;
	}
}



Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode ground type BITMAPONLY | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type BITMAPONLY | NOHEATCLOUD;
		explode sleeve type BITMAPONLY | NOHEATCLOUD;
		explode barrel1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FALL | NOHEATCLOUD;
		explode barrel1 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		explode barrel3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode ground type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode barrel3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
