
#include "../recoil_common_includes.h"

piece  base, turret, barrel1, flare1, barrel2, flare2, barrel3, flare3, sleeve, foreturret, foregun, foreflare, aftturret, aftgun, aftflare, wake, bow;

static-var  gun_1, restore_delay, gun_2, aimDir3, aimDir;

#define DEBUG
#include "../debug.h"

// Signal definitions
#define SIGNAL_AIM2 512
#define SIGNAL_AIM1 256
#define SIGNAL_MOVE 1

#define BASEPIECE base
#define HITSPEED <20.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 200

//#include "../unit_hitbyweaponid_and_smoke.h"


// -------------------------------- WARSHIP ------------------------
// bar_ship_common.h
// Author: (c) Beherith (mysterme@gmail.com)
// This is a collection of functions that provide a physical simulation of a ship
//	- The ship is modeled as a body with two different axes of rotation moments of inertia
// 		- Thus the rotations around X (pitch) and Z (roll) are independently calculated
//	- Movement of the ship changes the pitch and roll targets (of where the centers should be)
//  - List of movements:
//		- pitch backwards when going near full speed 
//		- pitch backwards when accelerating
//  	- roll into the turn when turning
//		- maintain the energy of the system, with adjustable constant and turn velocity dependent damping factors
//		- additional kickback velocity when firing weapons (aimdirs must be tracked, energy must be defined)
//		- Hit by weapon also adds energy to system via velocity
//		- if the unit goes idle and stops moving, add random energy into the system via a velocity kick
// Notes
//	- For increased precision, the energy of the ship is modeled at x256 fixed points (vs Cob Angular Units)
//	- Yes it is very easy to make the system go absolutely crazy
//	- By defaults, updates are performed every 2 frames, this is a good balance between performance and visuals		
//	- Uses its own DamagedSmoke because HitByWeaponID has to be hooked into
//	- Does not need a separate ground piece
//  - You can correct the aim pitch of a turret due to movement with RB_AIMPITCHCORRECTION(heading)
// Usage
//	- Actually read through the defines and think!
//	- #define what defaults you want to change
//  - #include this file
//  - call-script InitRockBoat(); from Create()
//	- start-script BoatPhysics(); from Create() after waiting for construction completion in 
//  - Recoil: Store the aim directions of weapons from AimWeaponX in static-vars, and pass them into 
//		- start/call-script RecoilRockBoat(heading,power,sleep); 
//		- Directly add energy into the system via RB_RECOILBOAT(heading, power)
//	- Set the usual UNITSIZE (default (WIDTH+LENGTH)/2) and MAXTILT for HitByWeapon

// Notes, Todo etc:
// [X] Make damping factor scale with current pitch and roll
// [X] Fix rounding of angular acceleration at <1.0
// [X] Rock when slow, do this by modulating the 'target pos' 
// [X] pitch forward when moving fast
// [X] bank when turning 
// [X] Bounce on high speed
//		[X] boats should rise upwards
//		[X] Ensure the bounce piece move happens before rot, yes move is before rot
// [X] Idle waves 
// [X] Independent axis damping if not specified
// [X] Damping should be velocity dependent!
// [X] Better Recoil handling 
// [X] Integrate SmokeUnit
// [ ] Minimize usage of local vars
// [X] Slave large turrets to RB_pitch/RB_roll (RB_AIMPITCHCORRECTION)
//		[X] Static-var the RB_pitch/RB_roll
// [NOTNEEEDED] separate ground and base, like for all other ships anyway too
//		[-] Movement physics based stuff should go onto base
//		[-] Recoil and hitbyweapon can go onto ground
//		[-] These could maybe use different speeds based on power, like missiles and stuff arent trivial
// [ ] emit sfx correctly
// [X] Do NOT use RockUnit, as there is only one callin for all weapons, and boats usually have more than one
// [X] Validate that updates every 2 frames are sufficient


//-------------------- INTERNAL DEFINES ------------------

//-------------------- MANDATORY DEFINES ------------------
#ifndef RB_BASE
	#define RB_BASE BASE
#endif

// mass of boat in AU
#ifndef RB_MASS
	#define RB_MASS 10
#endif

//Virtual Length of the boat, longer boats will have lower frequency pitches
#ifndef RB_LENGTH
	#define RB_LENGTH 8
#endif 

// Virtual width of boat, wider boats will roll slower
#ifndef RB_WIDTH
	#define RB_WIDTH 3
#endif

// How strongly the ship will pitch back and forth with forward acceleration
#ifndef RB_PITCH_ACCELERATION
	#define RB_PITCH_ACCELERATION 
#endif

// How often should BoatPhysics update, Only set it to 1 for rare, fast boats
#ifndef RB_FRAMES
	#define RB_FRAMES 2
#endif

// How tall, in elmos, the unit should Bounce at full speed
#ifndef RB_BOUNCE_HEIGHT
	#define RB_BOUNCE_HEIGHT [2.0]
#endif

// in degrees per frame
#ifndef RB_BOUNCE_PERIOD
	#define RB_BOUNCE_PERIOD <5>
#endif

// Phase offsets 
#ifndef RB_BOWSPLASH1_PHASE
	#define RB_BOWSPLASH1_PHASE <90>
#endif

#ifndef RB_BOWSPLASH2_PHASE
	#define RB_BOWSPLASH2_PHASE <270>
#endif

// The amount of energy imparted to the boat when it becomes idle to rock it around
#ifndef RB_IDLE_KICK 
	#define RB_IDLE_KICK 5000
#endif


//------------------- OPTIONAL DEFINES ------------------
#define RB_RECOIL_ENERGY_1 3500
#define RB_RECOIL_ENERGY_3 500

// RB_DAMPFACTOR is the velocity dependent damping, so faster moves are damped more.
// Higher numbers mean less damping
#define RB_DAMPFACTOR 1000

// Constant damping factors, higher number more damping. 
#define RB_PITCH_DAMPING 4
#define RB_ROLL_DAMPING  2

#define RB_MAX_PITCH

// How often should the speed/position of the boat be adjusted
// 1: 1.8% CPU/1k, for flagships only
// 2: 1.1% CPU/1k  for smaller boats
// 3: 0.8% CPU/1k  if you really wanna save a tiny bit of perf


#define RB_WAVE_FRAMES 5

// ------------------ INTERNAL DEFINES ------------------

#define RB_INERTIA_PITCH ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_LENGTH * RB_LENGTH) / (10))
#define RB_INERTIA_ROLL  ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_WIDTH  * RB_WIDTH ) / (10))

#define RB_RECOILBOAT(heading, power) \
	RB_pitch_velocity = RB_pitch_velocity - (get KCOS(heading) * power) / RB_MASS; \
	RB_roll_velocity  = RB_roll_velocity  - (get KSIN(heading) * power) / RB_MASS;


// Goes from <-180> - <180> (32760)
// 16 instructions
#define DELTAHEADING(curr, prev) ((curr - prev + 98280) % 65520 - 32760)

// Pitch is the X axis
// Roll is the Z axis
static-var RB_pitch, RB_roll, maxSpeed;
// Target is changed by the movement of the unit
static-var RB_pitch_target, RB_roll_target;
// Velocity is changed by impulse from being shot and from shooting
static-var RB_pitch_velocity, RB_roll_velocity;

// Always zero this in startmoving
static-var RB_bounce_frame;

InitRockBoat(){
	RB_pitch_target = 0;
	RB_roll_target = 0;
	RB_pitch = 0;
	RB_roll = 0;
	maxSpeed = get (MAX_SPEED);

	#ifdef DEBUG
		RB_pitch_velocity = 32000;
		RB_roll_velocity = 32000; 	
		/*
		dbg(RB_INERTIA_PITCH, RB_INERTIA_ROLL);
		var deltat;
		deltat = get GAME_FRAME;
		sleep 63;
		while(1){
			sleep 32;
			if ((currpitch / 100) == 0 ){
				
				deltat = (get GAME_FRAME) - deltat;
				dbg(deltat, currpitch);
				return(0);
			}
		}
		*/
	#else
		RB_pitch_velocity = 0;
		RB_roll_velocity = 0; 
	#endif
}


BoatPhysics(){
	var torque_pitch;
	var torque_roll;

	turn RB_BASE to x-axis RB_pitch now;
	turn RB_BASE to z-axis RB_roll  now;
	
	var currHeading, currSpeed, prevHeading_delta, prevSpeed_delta;	
	prevSpeed_delta = get (CURRENT_SPEED);
	prevHeading_delta = get (HEADING);

	var curr_bounce;
	curr_bounce = 0;
	var cos_bounce;
	cos_bounce = 0;


	while (1){
		

		// Get Speed and Heading, store the deltas
		currSpeed =   get (CURRENT_SPEED); // usually around 100,000
		prevSpeed_delta = currSpeed - prevSpeed_delta;

		currHeading = get (HEADING);
		prevHeading_delta = DELTAHEADING(currHeading, prevHeading_delta);

		// Move the pitch target backwards when going fast
		// And keep it back when going fast
		RB_pitch_target = -2 *( 10* prevSpeed_delta + currSpeed) ;
		
		// Roll the boat more when turning at high speed
		RB_roll_target = 4 * (prevHeading_delta/ RB_FRAMES) * ((256* (currSpeed + maxSpeed)) / maxSpeed);

		// Save the vars, as we wont be using them again
		prevHeading_delta = currHeading;
		prevSpeed_delta = currSpeed;

		// Calculate restoring torque due to displacement
		torque_pitch =  ( (RB_pitch - RB_pitch_target) * (-1 * RB_LENGTH));
		torque_roll =   ( (RB_roll  - RB_roll_target ) * (-1 * RB_WIDTH ));

		// Update angular velocity with angular acceleration
		RB_pitch_velocity = RB_pitch_velocity +  (torque_pitch ) / (RB_INERTIA_PITCH * RB_FRAMES );
		RB_roll_velocity  = RB_roll_velocity  +  (torque_roll  ) / (RB_INERTIA_ROLL  * RB_FRAMES ) ;
		
		// Simple damping to simulate resistance from water and air
		RB_pitch_velocity =  (RB_pitch_velocity * (256 -  (RB_FRAMES * RB_PITCH_DAMPING) - (get ABS(RB_pitch_velocity))/(RB_DAMPFACTOR/ RB_FRAMES))/256 ) ;
		RB_roll_velocity  =  (RB_roll_velocity  * (256 -  (RB_FRAMES * RB_ROLL_DAMPING ) - (get ABS(RB_roll_velocity ))/(RB_DAMPFACTOR/ RB_FRAMES))/256 ) ;
		//dbg((get ABS(RB_pitch_velocity)))/RB_DAMPFACTOR, (get ABS(RB_roll_velocity)))/RB_DAMPFACTOR);

		//if(currSpeed > 0 ) dbg(torque_roll, RB_roll_velocity);
		// Update pitch and roll based on angular velocity
		RB_pitch = RB_pitch + RB_FRAMES * RB_pitch_velocity;
		RB_roll  = RB_roll  + RB_FRAMES * RB_roll_velocity;
		
				// emit a wakesplash on up and down bounce
		// increment bounce phase and modulo it
		if (currSpeed> 0){
			RB_bounce_frame = (RB_bounce_frame + RB_FRAMES * RB_BOUNCE_PERIOD);
			// emit a the bottom peak
			if (RB_bounce_frame >= <360>){
				RB_bounce_frame = 0;
			}

			// BowSplash Phase 1
			if (RB_bounce_frame >= RB_BOWSPLASH1_PHASE && RB_bounce_frame < (RB_BOWSPLASH1_PHASE + RB_FRAMES * RB_BOUNCE_PERIOD)){
				emit-sfx 1024 + 2 from bow;
			}

			// BowSplash Phase 2
			if (RB_bounce_frame >= RB_BOWSPLASH2_PHASE && RB_bounce_frame < (RB_BOWSPLASH2_PHASE + RB_FRAMES * RB_BOUNCE_PERIOD)){
				emit-sfx 1024 + 2 from bow;
			}
			
			// Calculate Bounce, be careful that your int doesnt overflow
			// Start at the -1 point of the cosine with + <180>
			cos_bounce = (get KCOS(RB_bounce_frame + <180>) + 1024);

			curr_bounce = RB_BOUNCE_HEIGHT * ((256 * currSpeed) / maxSpeed)/ 256;

			move RB_BASE to y-axis curr_bounce * cos_bounce / 1024 speed [500];
		}
		//If we are stationary, give us a kick
		else
		{
			//  if( ABS(X) < Y) === if (X/Y == 0)
			if (RB_pitch_velocity / 16 == 0) {
				RB_pitch_velocity = RAND(-1 * RB_IDLE_KICK, RB_IDLE_KICK);
				dbg(7777);
			}

			if (RB_roll_velocity / 16 == 0) {
				RB_roll_velocity =  RAND(-1 * RB_IDLE_KICK, RB_IDLE_KICK);
				dbg(8888);
			}
		}

		// Execute corresponding movements
		#if (RB_FRAMES == 1)
			if (RB_pitch_velocity != 0) turn RB_BASE to x-axis (RB_pitch/256) speed (30 * RB_pitch_velocity )/256;  
			if (RB_roll_velocity  != 0) turn RB_BASE to z-axis (RB_roll /256) speed (30 * RB_roll_velocity  )/256; 
		#else
			turn RB_BASE to x-axis (RB_pitch/256) speed (30) * RB_pitch_velocity / 256;
			turn RB_BASE to z-axis (RB_roll /256) speed (30) * RB_roll_velocity / 256;
		#endif
	
		sleep 33 * RB_FRAMES - 1;
	}
}

// This is for correcting the pitch of an aim on a moving boat
#define RB_AIMPITCHCORRECTION(heading) (get KSIN(heading)*(RB_roll/(-256)) + (get KCOS(heading))*(RB_pitch/(-256)) )/1024

// Pass in the heading of the current aiming here 
// You will need to save the headings of weapons 
// heading: 0 is forward, 16K is 90deg left, -16K is 90 deg right
// This can be start-script-ed, if a frame of delay is needed but immediate return is needed
RecoilRockBoat(heading, power, delay){
	// Add with negative sign as we want it to move backwards from heading;
	if (delay) sleep delay;
	RB_RECOILBOAT(heading, power)
}

// anglez is left-right, +500 right
// anglex is front-back, where +500 is front
#ifndef UNITSIZE
	#define UNITSIZE (RB_LENGTH + RB_WIDTH)/2
#endif
#ifndef MAXTILT
	#define MAXTILT 100
#endif

static-var isSmoking;

// MUST IMMEDIATELY RETURN DAMAGE AMOUNT!
HitByWeaponId(anglex, anglez, weaponid, damage) 
{

	damage = damage / (100 * UNITSIZE);
	if (damage < 3  ) return (0);
	if (damage > MAXTILT) damage = MAXTILT;

	RB_pitch_velocity = RB_pitch_velocity - (anglex * damage) ;
	RB_roll_velocity  = RB_roll_velocity  + (anglez * damage) ;

	// Dont do anything if we are being built
	if (get BUILD_PERCENT_LEFT) return (100);
	// Dont start a damagedSmoke thread if we arent low health
	if ((get HEALTH) > 65){
		// Start a thread if werent previously smoking
		if (isSmoking == 0)	{ 
			isSmoking = 1;
			start-script DamagedSmoke();
		}	
	}	
	return (100); //return damage percent
}


DamagedSmoke() // ah yes, clever use of stack variables 
{
	var current_health_pct; // [0-100]
	while( TRUE )
	{
		current_health_pct = get HEALTH;
		if (current_health_pct > 65) {
			isSmoking = 0;
			return;
		}

		if (current_health_pct < 4) current_health_pct = 4;

		// Less health means blacker smoke
		if( Rand( 1, 65 ) < current_health_pct ) {
			emit-sfx 257 from BASEPIECE;
		}
		else {
			emit-sfx 258 from BASEPIECE;
		}

		// Sleep after emission to get immediate visual of unit taking damage via smoke effect
		sleep (current_health_pct * 50);
	}
}



// -------------------------------- END WARSHIP --------------------

Create()
{
	hide bow;
	hide wake;
	hide flare2;
	hide flare3;
	hide flare1;
	hide aftflare;
	hide foreflare;
	//hide ground;
	hide flare1;
	hide flare2;
	hide foreflare;
	hide aftflare;
	gun_1 = 0;
	gun_2 = 0;
	start-script InitRockBoat();
	SLEEP_UNTIL_UNITFINISHED;
	start-script BoatPhysics();
}

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	set-signal-mask 0;
	turn turret to y-axis <0.0> speed <55.0>;
	turn barrel1 to x-axis <0.0> speed <15.0>;
	turn barrel2 to x-axis <0.0> speed <15.0>;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

RestoreDeckLaser()
{
	sleep 3000;
	set-signal-mask 0;
	turn foreturret to y-axis <0.0> speed <150.0>;
	turn foregun to x-axis <0.0> speed <100.0>;
	turn aftturret to y-axis <0.0> speed <150.0>;
	turn aftgun to x-axis <0.0> speed <100.0>;
}

waveSplash()
{
	return (0);
	while( TRUE )
	{
		turn base to x-axis <-3.0> speed <3.0>;
		move base to y-axis [0.32] speed [0.25];
		wait-for-turn base around x-axis;
		turn base to x-axis <0.0> speed <3.0>;
		move base to y-axis [0.0] speed [0.25];
		wait-for-turn base around x-axis;
	}
}

StartMoving(reversing)
{
	signal SIGNAL_MOVE;
	set-signal-mask SIGNAL_MOVE;
	var waketime;
	RB_bounce_frame = RAND(0, <180>);
	/*
	start-script waveSplash();
	var bowtime;
	bowtime = 0;
	while( TRUE )
	{
		emit-sfx 1024 + 1 from wake;
		if (bowtime) emit-sfx 1024 + 2 from bow;
        bowtime = !bowtime;
		waketime = (get CURRENT_SPEED) * 100 / get MAX_SPEED;
		if( waketime < 50 ) waketime = 50;
		sleep 10000 / waketime;
	}
	*/
}

StopMoving()
{
	signal SIGNAL_MOVE;
	turn base to x-axis <0.0> speed <3.0>;
	move base to y-axis [0.0] speed [0.25];
}

AimWeapon2(heading, pitch)
{
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;
	if( gun_2 )
	{
		turn aftturret to y-axis heading speed <300.0>;
		turn aftgun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn aftturret around y-axis;
		wait-for-turn aftgun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
	else
	{
		turn foreturret to y-axis heading speed <300.0>;
		turn foregun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn foreturret around y-axis;
		wait-for-turn foregun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
}

FireWeapon2()
{
	gun_2 = !gun_2;
}

AimFromWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftgun;
	}
	else
	{
		pieceIndex = foregun;
	}
}

QueryWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftflare;
	}
	else
	{
		pieceIndex = foreflare;
	}
}

AimWeapon3(heading, pitch)
{
	aimDir3 = heading;
	return (1);
}

FireWeapon3()
{
	sleep 150;
	
	//call-script RecoilRockBoat(aimDir3, RB_RECOIL_ENERGY_3);
	RB_RECOILBOAT(aimDir3, RB_RECOIL_ENERGY_3);
}

AimFromWeapon3(pieceIndex)
{
	pieceIndex = base;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = base;
}

AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;

	//var ph, rh;
	//ph = get KCOS(heading); 
	//rh = get KSIN(heading);// X angle
	//dbg(heading,ph,RB_pitch, rh, RB_roll);

	turn turret to y-axis heading speed <110.0>;
	//turn sleeve to x-axis <0.0> - pitch speed <90.0>;

	#define RB_AIMPITCHCORRECTION(heading) (get KSIN(heading)*(RB_roll/(-256)) + (get KCOS(heading))*(RB_pitch/(-256)) )/1024
	turn sleeve to x-axis RB_AIMPITCHCORRECTION(heading) - pitch speed <30.0>;
	//turn sleeve to x-axis (-1*rh*(RB_roll /256))/(1024) - pitch speed <90.0>;
	//turn sleeve to x-axis (-1*ph*(RB_pitch/256))/(1024) - pitch speed <45.0>;
	wait-for-turn turret around y-axis;
	//wait-for-turn sleeve around x-axis;
	aimDir = heading;
	start-script RestoreAfterDelay();
	return (1);
}

FireWeapon1()
{
	//start-script RockZ(-7, aimDir);
	if( gun_1 ==0)
	{
	    emit-sfx 1024 + 0 from flare1;
		move barrel1 to z-axis [-2.300000] now;
		move barrel1 to z-axis [0.0] speed [1.500000];
	}
	else if (gun_1==1)
	{
	    emit-sfx 1024 + 0 from flare2;
		move barrel2 to z-axis [-2.300000] now;
		move barrel2 to z-axis [0.0] speed [1.500000];
	}else
	{
	    emit-sfx 1024 + 0 from flare3;
		move barrel3 to z-axis [-2.300000] now;
		move barrel3 to z-axis [0.0] speed [1.500000];
	}
	gun_1=gun_1+1;
	if (gun_1>2){
		gun_1=0;
	}
	
	// A bit of delay before adding velocity looks way better :D
	//#IF RB_FRAMES == 1
	//	sleep 65;
	//#ENDIF
	sleep 65 - 32 * RB_FRAMES;
	//call-script RecoilRockBoat(aimDir, RB_RECOIL_ENERGY_1);
	RB_RECOILBOAT(aimDir, RB_RECOIL_ENERGY_1);
}

AimFromWeapon1(pieceIndex)
{
	pieceIndex = turret;
}

QueryWeapon1(pieceIndex)
{
	if( gun_1 ==0)
	{
		pieceIndex = flare1;
	}
	else if( gun_1 ==1)
	{
		pieceIndex = flare2;
	}
	else
	{
		pieceIndex = flare3;
	}
}



Killed(severity, corpsetype)
{
	
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type BITMAPONLY | NOHEATCLOUD;
		explode sleeve type BITMAPONLY | NOHEATCLOUD;
		explode barrel1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FALL | NOHEATCLOUD;
		explode barrel1 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		explode barrel3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode barrel3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
