
#include "../recoil_common_includes.h"

piece  base, turret, barrel1, flare1, barrel2, flare2, barrel3, flare3, sleeve, foreturret, foregun, foreflare, aftturret, aftgun, aftflare, ground, wake, bow;

static-var  gun_1, restore_delay, gun_2, Static_Var_7, aimDir3, aimDir, oldHead;

// Signal definitions
#define SIGNAL_AIM2 512
#define SIGNAL_AIM1 256
#define SIGNAL_MOVE 1

#define BASEPIECE base
#define HITSPEED <20.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 200

//#include "../unit_hitbyweaponid_and_smoke.h"



// -------------------------------- WARSHIP ------------------------
// TODO:
// [ ] Make damping factor scale with current pitch and roll
// [X] Fix rounding of angular acceleration at <1.0
// [ ] Rock when slow, do this by modulating the 'target pos' 
// [ ] pitch forward when moving fast
// [X] bank when turning 
// [ ] Bounce on high speed
// [ ] Idle waves 
// [ ] Independent axis damping if not specified
// [ ] Better Recoil handling 
// [ ] Integrate SmokeUnit
// [ ] Minimize useage of local vars


// REQUIRED STATIC VARS:
// heading


//-------------------- EXTERNAL DEFINES ------------------
// mass of boat in AU
#define RB_MASS 100

//Virtual Length and width of boat in elmos, assume the boat is a tall as it is wide
#define RB_LENGTH 10
#define RB_WIDTH 3

#define RB_RECOIL_ENERGY_1 3
#define RB_RECOIL_ENERGY_3 0
#define RB_PIECE ground

// where 0 is no damping.
#define RB_PITCH_DAMPING 2
#define RB_ROLL_DAMPING  2

// How often should the speed/position of the boat be adjusted
// 1: 1.8% CPU/1k, for flagships only
// 2: 1.1% CPU/1k  for smaller boats
// 3: 0.8% CPU/1k  if you really wanna save a tiny bit of perf

#define RB_FRAMES 1

#define RB_WAVE_FRAMES 5

// ------------------ INTERNAL DEFINES ------------------

#define RB_INERTIA_PITCH ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_LENGTH * RB_LENGTH) / (120))
#define RB_INERTIA_ROLL  ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_WIDTH  * RB_WIDTH ) / (120))
#define SIGN(v) ((v > 0) - (v < 0)) 
#define ABS(v) (v * (-1 * (v<0)))
// 15 commands to MAX, pretty bad
#define MAX(v,m) ((v * (v > m)) + ((v <= m)* m))
#define MIN(v,m) ((v * (v < m)) + ((v >= m)* m))

#define RB_RECOILBOAT(heading, power) \
	RB_pitch_velocity = RB_pitch_velocity - (get KCOS(heading) * power) / RB_MASS; \
	RB_roll_velocity  = RB_roll_velocity  - (get KSIN(heading) * power) / RB_MASS;

// Goes from <-180> - <180> (32760)
// 16 instructions
#define DELTAHEADING(curr, prev) ((curr - prev + 98280) % 65520 - 32760)

// Pitch is the X axis
// Roll is the Z axis
// Target is changed by the movement of the unit
static-var RB_pitch_target, RB_roll_target;
// Velocity is changed by impulse from being shot and from shooting
static-var RB_pitch_velocity, RB_roll_velocity;

InitRockBoat(){
	var RB_pitch;
	var RB_roll;
	
	RB_pitch = 0;
	RB_roll = 0;
	RB_pitch_velocity = 0;
	RB_roll_velocity = 0; 
	RB_pitch_target = 0;
	RB_roll_target = 0;
	
	var torque_pitch;
	var torque_roll;
	
	var game_frame;
	game_frame = RAND(1, 100);
	
	turn RB_PIECE to x-axis RB_pitch now;
	turn RB_PIECE to z-axis RB_roll  now;
	
	var currHeading, currSpeed, prevHeading_delta, prevSpeed_delta;	
	prevSpeed_delta = get (CURRENT_SPEED);
	prevHeading_delta = get (HEADING);
	
	var maxSpeed;
	maxSpeed = get (MAX_SPEED);

	while (1){
		game_frame = game_frame + RB_FRAMES;
		if ((game_frame % RB_WAVE_FRAMES) == 0){
			//game_frame = 0;
	
			currSpeed =   get (CURRENT_SPEED);
			prevSpeed_delta = currSpeed - prevSpeed_delta;
			RB_pitch_target = -1 *( 10* prevSpeed_delta + currSpeed) / 200;
			
			currHeading = get (HEADING);
			prevHeading_delta = DELTAHEADING(currHeading, prevHeading_delta);
			RB_roll_target = (prevHeading_delta * currSpeed) / maxSpeed;
			
			//get PRINT(currHeading, currSpeed, prevHeading_delta, currHeading - prevHeading_delta);
			if ((currSpeed < 1000) AND ((game_frame % (5 * RB_WAVE_FRAMES)) == 0)){
				RB_pitch_target = RAND(1, 1000)-500;
				RB_roll_target = RAND(1, 1000) -500;
			}else{
				
			}
			
			
			prevHeading_delta = currHeading;
			prevSpeed_delta = currSpeed;
			
		}
		
		
		// Calculate restoring torque due to displacement
		torque_pitch = ( (RB_pitch - RB_pitch_target) * (-1 *  RB_LENGTH))/10;
		torque_roll =  ( (RB_roll  - RB_roll_target ) * (-1 *  RB_WIDTH ))/10;
		
		//silly max without jump
		//torque_pitch = (torque_pitch > 100) * 100 + (torque_pitch <= 100) * torque_pitch;
		//if (torque_pitch > 100) torque_pitch = 100;
		//if (torque_roll > 100)   torque_roll = 100;
		//if (torque_pitch < -100) torque_pitch = -100;
		//if (torque_roll < -100)   torque_roll = -100;
		
		// Print debugging stuff:
		//get PRINT(88888, torque_pitch, torque_roll);

		// Convert torque to angular acceleration 
		//RB_angular_acceleration_pitch = (   torque_pitch) / RB_INERTIA_PITCH;
		//RB_angular_acceleration_roll  = (   torque_roll ) / RB_INERTIA_ROLL ;
		
		// Update angular velocity with angular acceleration
		RB_pitch_velocity = RB_pitch_velocity + RB_FRAMES * (torque_pitch ) / RB_INERTIA_PITCH;
		RB_roll_velocity  = RB_roll_velocity  + RB_FRAMES * (torque_roll  ) / RB_INERTIA_ROLL ;
		
		// Simple damping to simulate resistance from water and air
		RB_pitch_velocity = ( (RB_pitch_velocity * (100 - RB_PITCH_DAMPING)) / 100) ;
		RB_roll_velocity  = ( (RB_roll_velocity  * (100 - RB_ROLL_DAMPING )) / 100) ;
		
		if (RB_pitch_velocity == 0) {
			if (RB_pitch > 0) RB_pitch_velocity = -1;
			else RB_pitch_velocity = 1;
		}
		
		//RB_pitch_velocity = MAX(RB_pitch_velocity, 1) * SIGN(RB_pitch);
		
		if (RB_roll_velocity == 0) {
			if (RB_roll > 0) RB_roll_velocity = -1;
			else RB_roll_velocity = 1;
		}
		
		// Print debugging stuff:
		//get PRINT(RB_roll_velocity, RB_roll_velocity, RB_angular_acceleration_pitch, RB_angular_acceleration_roll);
		
		// Update pitch and roll based on angular velocity
		RB_pitch = RB_pitch + RB_FRAMES* RB_pitch_velocity ;
		RB_roll  = RB_roll  + RB_FRAMES* RB_roll_velocity;

		// Print debugging stuff:
		//get PRINT(RB_pitch, RB_roll, RB_pitch_velocity, RB_roll_velocity);
		//get PRINT(RB_pitch, RB_roll);

		// Execute corresponding movements
		#if (RB_FRAMES == 1)
			#if 0
			if (RB_pitch_velocity != 0) turn RB_PIECE to x-axis RB_pitch now; 
			if (RB_roll_velocity  != 0) turn RB_PIECE to z-axis RB_roll now; 
			#else
				if (RB_pitch_velocity != 0) turn RB_PIECE to x-axis RB_pitch speed 30 * RB_pitch_velocity; 
				if (RB_roll_velocity  != 0) turn RB_PIECE to z-axis RB_roll speed 30 * RB_roll_velocity; 
			#endif
		#else
			turn RB_PIECE to x-axis RB_pitch speed (30 / RB_FRAMES) * RB_pitch_velocity;
			turn RB_PIECE to z-axis RB_roll  speed (30 / RB_FRAMES) * RB_roll_velocity;
		#endif
		
		
		sleep 32 * RB_FRAMES;

	}
}

// Pass in the pitch and heading of the current aiming here 
// heading: 0 is forward, 16K is 90deg left, -16K is 90 deg right
RecoilRockBoat(heading, power){
	// Separate heading into X and Z axes
	// Where RockZComponent is +1024 on the heading = left, RockXComponent is +1024 when aiming forward
	//get PRINT (heading,power, KSIN(heading), KCOS(heading));
	
	// Add with negative sign as we want it to move backwards from heading;
	
	RB_pitch_velocity = RB_pitch_velocity - (get KSIN(heading) * power) / RB_MASS;
	RB_roll_velocity  = RB_roll_velocity  - (get KCOS(heading) * power) / RB_MASS;
	
}

RockOnWaves()
{
	var currHeading, currSpeed, prevHeading_delta, prevSpeed_delta;	
	var maxSpeed;
	maxSpeed = get (MAX_SPEED);
	
	while( TRUE )
	{
		// get HEADINNG returns 0 when unit points South, 16K when unit points West, -16K when unit points East

		currSpeed =   get (CURRENT_SPEED);
		prevSpeed_delta = currSpeed - prevSpeed_delta;
		RB_pitch_target = -1 *( 200* prevSpeed_delta + currSpeed) / 200;
		
		currHeading = get (HEADING);
		prevHeading_delta = DELTAHEADING(currHeading, prevHeading_delta);
		RB_roll_target = (prevHeading_delta * currSpeed) / maxSpeed;
		
		//get PRINT(currHeading, currSpeed, prevHeading_delta, currHeading - prevHeading_delta);
		prevHeading_delta = currHeading;
		prevSpeed_delta = currSpeed;
		sleep 198;
	}
}


// anglez is left-right, +500 right
// anglex is front-back, where +500 is front

// only called if HitByWeaponId NOT defined
//HitByWeapon(anglex, anglez, damage)	// angle[x|z] is always [-500;500], damage is multiplied by 100
//{
//	get PRINT(-1000, anglex, anglez, damage);	
//}

// If HitByWeaponId is defined, then HitByWeapon is not called 
// anglez is left-right, +500 right
// anglex is front-back, where +500 is front

#define UNITSIZE (RB_LENGTH + RB_WIDTH)/2
#define MAXTILT 200

HitByWeaponId(anglex, anglez, weaponid, damage) //weaponID is always 0,lasers and flamers give angles of 0
{
	damage = damage / (100 * UNITSIZE);
	if (damage < 3  ) return (0);
	if (damage > MAXTILT) damage = MAXTILT;
	
	//get PRINT(anglex, anglez, weaponid, damage);
	RB_pitch_velocity = RB_pitch_velocity - (anglex * damage)  / 400 ;
	RB_roll_velocity  = RB_roll_velocity  + (anglez * damage)  / 400;
	// always return 100% damage!
	return (0); 
}

// -------------------------------- END WARSHIP --------------------

/*
RockOnWaves()
{
	var rockDir, rockAng, rockSpeed;
	rockDir = <-0.1>;
	rockAng = <-0.1>;
	while( TRUE )
	{
		while( get ABS(rockAng) < <1.31> )
		{
			rockSpeed = <1.45> - get ABS(rockAng);
		//	turn ground to x-axis rockAng speed rockSpeed*4;
		//	wait-for-turn ground around x-axis;
			rockAng = rockAng + rockDir;
			sleep 1;
		}
		rockDir = 0 - rockDir;
		rockAng = rockAng + rockDir + rockDir;
	}
}*/

Create()
{
	hide bow;
	hide wake;
	hide flare2;
	hide flare3;
	hide flare1;
	hide aftflare;
	hide foreflare;
	hide ground;
	hide flare1;
	hide flare2;
	hide foreflare;
	hide aftflare;
	gun_1 = base;
	gun_2 = base;
	restore_delay = 3000;
	SLEEP_UNTIL_UNITFINISHED;
	//start-script RockOnWaves();
	start-script InitRockBoat();
}

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	set-signal-mask 0;
	turn turret to y-axis <0.0> speed <55.0>;
	turn barrel1 to x-axis <0.0> speed <15.0>;
	turn barrel2 to x-axis <0.0> speed <15.0>;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

RestoreDeckLaser()
{
	sleep 3000;
	set-signal-mask 0;
	turn foreturret to y-axis <0.0> speed <150.0>;
	turn foregun to x-axis <0.0> speed <100.0>;
	turn aftturret to y-axis <0.0> speed <150.0>;
	turn aftgun to x-axis <0.0> speed <100.0>;
}

waveSplash()
{
	return (0);
	while( TRUE )
	{
		turn base to x-axis <-3.0> speed <3.0>;
		move base to y-axis [0.32] speed [0.25];
		wait-for-turn base around x-axis;
		turn base to x-axis <0.0> speed <3.0>;
		move base to y-axis [0.0] speed [0.25];
		wait-for-turn base around x-axis;
	}
}

StartMoving(reversing)
{
	signal SIGNAL_MOVE;
	set-signal-mask SIGNAL_MOVE;
	var waketime;
	start-script waveSplash();
	var bowtime;
	bowtime = 0;
	while( TRUE )
	{
		emit-sfx 1024 + 1 from wake;
		if (bowtime) emit-sfx 1024 + 2 from bow;
        bowtime = !bowtime;
		waketime = (get CURRENT_SPEED) * 100 / get MAX_SPEED;
		if( waketime < 50 ) waketime = 50;
		sleep 10000 / waketime;
	}
}

StopMoving()
{
	signal SIGNAL_MOVE;
	turn base to x-axis <0.0> speed <3.0>;
	move base to y-axis [0.0] speed [0.25];
}

AimWeapon2(heading, pitch)
{
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;
	if( gun_2 )
	{
		turn aftturret to y-axis heading speed <300.0>;
		turn aftgun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn aftturret around y-axis;
		wait-for-turn aftgun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
	else
	{
		turn foreturret to y-axis heading speed <300.0>;
		turn foregun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn foreturret around y-axis;
		wait-for-turn foregun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
}

FireWeapon2()
{
	gun_2 = !gun_2;
}

AimFromWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftgun;
	}
	else
	{
		pieceIndex = foregun;
	}
}

QueryWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftflare;
	}
	else
	{
		pieceIndex = foreflare;
	}
}

AimWeapon3(heading, pitch)
{
	aimDir3 = heading;
	return (1);
}

FireWeapon3()
{
	sleep 150;
	
	//call-script RecoilRockBoat(aimDir3, RB_RECOIL_ENERGY_3);
	RB_RECOILBOAT(aimDir3, RB_RECOIL_ENERGY_3);
}

AimFromWeapon3(pieceIndex)
{
	pieceIndex = base;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = base;
}

AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;
	turn turret to y-axis heading speed <110.0>;
	turn sleeve to x-axis <0.0> - pitch speed <90.0>;
	wait-for-turn turret around y-axis;
	//wait-for-turn sleeve around x-axis;
	aimDir = heading;
	start-script RestoreAfterDelay();
	return (1);
}

FireWeapon1()
{
	//start-script RockZ(-7, aimDir);
	if( gun_1 ==0)
	{
	    emit-sfx 1024 + 0 from flare1;
		move barrel1 to z-axis [-2.300000] now;
		move barrel1 to z-axis [0.0] speed [1.500000];
	}
	else if (gun_1==1)
	{
	    emit-sfx 1024 + 0 from flare2;
		move barrel2 to z-axis [-2.300000] now;
		move barrel2 to z-axis [0.0] speed [1.500000];
	}else
	{
	    emit-sfx 1024 + 0 from flare3;
		move barrel3 to z-axis [-2.300000] now;
		move barrel3 to z-axis [0.0] speed [1.500000];
	}
	gun_1=gun_1+1;
	if (gun_1>2){
		gun_1=0;
	}
	
	// A bit of delay before adding velocity looks way better :D
	//#IF RB_FRAMES == 1
	//	sleep 65;
	//#ENDIF
	sleep 65 - 32 * RB_FRAMES;
	//call-script RecoilRockBoat(aimDir, RB_RECOIL_ENERGY_1);
	RB_RECOILBOAT(aimDir, RB_RECOIL_ENERGY_1);
}

AimFromWeapon1(pieceIndex)
{
	pieceIndex = turret;
}

QueryWeapon1(pieceIndex)
{
	if( gun_1 ==0)
	{
		pieceIndex = flare1;
	}
	else if( gun_1 ==1)
	{
		pieceIndex = flare2;
	}
	else
	{
		pieceIndex = flare3;
	}
}



Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode ground type BITMAPONLY | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type BITMAPONLY | NOHEATCLOUD;
		explode sleeve type BITMAPONLY | NOHEATCLOUD;
		explode barrel1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FALL | NOHEATCLOUD;
		explode barrel1 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		explode barrel3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode ground type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode barrel3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
