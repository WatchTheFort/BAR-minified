
#include "../recoil_common_includes.h"

piece  base, ground, turret, barrel1, flare1, barrel2, flare2, barrel3, flare3, sleeve, foreturret, foregun, foreflare, aftturret, aftgun, aftflare, wake, bow;

static-var  gun_1, restore_delay, gun_2, Static_Var_7, aimDir3, aimDir, oldHead;

#define DEBUG
#include "../debug.h"

// Signal definitions
#define SIGNAL_AIM2 512
#define SIGNAL_AIM1 256
#define SIGNAL_MOVE 1

#define BASEPIECE base
#define HITSPEED <20.0>
//how 'heavy' the unit is, on a scale of 1-10
#define UNITSIZE 5
#define MAXTILT 200

//#include "../unit_hitbyweaponid_and_smoke.h"



// -------------------------------- WARSHIP ------------------------
// TODO:
// [ ] Make damping factor scale with current pitch and roll
// [X] Fix rounding of angular acceleration at <1.0
// [ ] Rock when slow, do this by modulating the 'target pos' 
// [ ] pitch forward when moving fast
// [X] bank when turning 
// [ ] Bounce on high speed
//		[ ] boats should rise upwards
//		[X] Ensure the bounce piece move happens before rot, yes move is before rot
// [ ] Idle waves 
// [ ] Independent axis damping if not specified
// [ ] Damping should be velocity dependent!
// [ ] Better Recoil handling 
// [ ] Integrate SmokeUnit
// [ ] Minimize useage of local vars
// [ ] separate ground and base, like for all other ships anyway too
//		[ ] Movement physics based stuff should go onto base
//		[ ] Recoil and hitbyweapon can go onto ground
//		[ ] These could maybe use different speeds based on power, like missiles and stuff arent trivial
// [ ] emit sfx correctly
// [ ] Do NOT use RockUnit, as there is only one callin for all weapons, and boats usually have more than one
// [ ] Validate that updates every 3 frames are sufficient

// REQUIRED STATIC VARS:
// the aim headings must be stored for all weapons

//-------------------- INTERNAL DEFINES ------------------

//-------------------- MANDATORY DEFINES ------------------
#ifndef RB_BASE
	#define RB_BASE BASE
#endif

// mass of boat in AU
#ifndef RB_MASS
	#define RB_MASS 80
#endif

//Virtual Length of the boat, longer boats will have lower frequency pitches
#ifndef RB_LENGTH
	#define RB_LENGTH 8
#endif 

// Virtual width of boat, widget boats will roll slower
#ifndef RB_WIDTH
	#define RB_WIDTH 3
#endif

// DO NOT TOUCH TODO
#ifndef RB_FRAMES
	#define RB_FRAMES 1
#endif

// How tall, in elmos, the unit should Bounce at full speed
#ifndef RB_BOUNCE_HEIGHT
	#define RB_BOUNCE_HEIGHT [2.0]
#endif

// in degrees per frame
#ifndef RB_BOUNCE_PERIOD
	#define RB_BOUNCE_PERIOD <7>
#endif

// Phase offsets 
#ifndef RB_BOWSPLASH1_PHASE
	#define RB_BOWSPLASH1_PHASE <90>
#endif

#ifndef RB_BOWSPLASH2_PHASE
	#define RB_BOWSPLASH2_PHASE <270>
#endif


//------------------- OPTIONAL DEFINES ------------------
#define RB_RECOIL_ENERGY_1 500
#define RB_RECOIL_ENERGY_3 0

// where 0 is no damping.

#define RB_DAMPFACTOR 1000
#define RB_PITCH_DAMPING 2
#define RB_ROLL_DAMPING  2

#define RB_MAX_PITCH

// How often should the speed/position of the boat be adjusted
// 1: 1.8% CPU/1k, for flagships only
// 2: 1.1% CPU/1k  for smaller boats
// 3: 0.8% CPU/1k  if you really wanna save a tiny bit of perf

#define RB_FRAMES 1

#define RB_WAVE_FRAMES 5

// ------------------ INTERNAL DEFINES ------------------

#define RB_INERTIA_PITCH ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_LENGTH * RB_LENGTH) / (10))
#define RB_INERTIA_ROLL  ((RB_MASS) * (RB_WIDTH * RB_WIDTH + RB_WIDTH  * RB_WIDTH ) / (10))

#define RB_RECOILBOAT(heading, power) \
	RB_pitch_velocity = RB_pitch_velocity - (get KCOS(heading) * power) / RB_MASS; \
	RB_roll_velocity  = RB_roll_velocity  - (get KSIN(heading) * power) / RB_MASS;

// Goes from <-180> - <180> (32760)
// 16 instructions
#define DELTAHEADING(curr, prev) ((curr - prev + 98280) % 65520 - 32760)

// Pitch is the X axis
// Roll is the Z axis
// Target is changed by the movement of the unit
static-var RB_pitch_target, RB_roll_target;
// Velocity is changed by impulse from being shot and from shooting
static-var RB_pitch_velocity, RB_roll_velocity;

// Always zero this in startmoving
static-var RB_bounce_frame;

InitRockBoat(){
	#ifdef DEBUG
		RB_pitch_velocity = 16000;
		RB_roll_velocity = 16000; 
	#else
		RB_pitch_velocity = 0;
		RB_roll_velocity = 0; 

	#endif
	RB_pitch_target = 0;
	RB_roll_target = 0;
	dbg(RB_INERTIA_PITCH, RB_INERTIA_ROLL);
}


BoatPhysics(){
	var RB_pitch;
	var RB_roll;
	
	RB_pitch = 0;
	RB_roll = 0;
	
	var torque_pitch;
	var torque_roll;

	
	turn RB_BASE to x-axis RB_pitch now;
	turn RB_BASE to z-axis RB_roll  now;
	
	var currHeading, currSpeed, prevHeading_delta, prevSpeed_delta;	
	prevSpeed_delta = get (CURRENT_SPEED);
	prevHeading_delta = get (HEADING);
	
	var maxSpeed;
	maxSpeed = get (MAX_SPEED);

	var curr_bounce;
	curr_bounce = 0;
	var cos_bounce;
	cos_bounce = 0;

	var tmp1, tmp2;
	tmp1 = 0;
	tmp2 = 0;

	while (1){
		


		// Get Speed and Heading, store the deltas
		currSpeed =   get (CURRENT_SPEED); // usually around 100,000
		prevSpeed_delta = currSpeed - prevSpeed_delta;

		currHeading = get (HEADING);
		prevHeading_delta = DELTAHEADING(currHeading, prevHeading_delta);

		// Move the pitch target backwards when going fast
		// And keep it back when going fast
		RB_pitch_target = -2 *( 10* prevSpeed_delta + currSpeed) ;
		
		// Roll the boat more when turning at high speed
		RB_roll_target = 4* prevHeading_delta * ((256* (currSpeed + maxSpeed)) / maxSpeed);
		//dbg(RB_pitch_target, RB_roll_target,prevHeading_delta);

		// Save the vars, as we wont be using them again
		prevHeading_delta = currHeading;
		prevSpeed_delta = currSpeed;

		
		//dbg(curr_bounce, currSpeed, maxSpeed,sin_bounce);

		// Calculate restoring torque due to displacement
		torque_pitch =  ( (RB_pitch - RB_pitch_target) * (-1 *  RB_LENGTH));
		torque_roll =   ( (RB_roll  - RB_roll_target ) * (-1 *  RB_WIDTH ));
		//dbg(torque_pitch, torque_roll);
		
		//Clamp
		//if (torque_pitch > 100) torque_pitch = 100;
		//if (torque_roll > 100)   torque_roll = 100;
		//if (torque_pitch < -100) torque_pitch = -100;
		//if (torque_roll < -100)   torque_roll = -100;
		
		// Update angular velocity with angular acceleration
		RB_pitch_velocity = RB_pitch_velocity + RB_FRAMES * (torque_pitch ) / RB_INERTIA_PITCH;
		RB_roll_velocity  = RB_roll_velocity  + RB_FRAMES * (torque_roll  ) / RB_INERTIA_ROLL ;
		
		// Simple damping to simulate resistance from water and air
		tmp1 = get ABS(RB_pitch_velocity);
		RB_pitch_velocity =  (RB_pitch_velocity * (256 - (RB_PITCH_DAMPING + tmp1/RB_DAMPFACTOR))/256 ) ;
		tmp2 = get ABS(RB_roll_velocity);
		RB_roll_velocity  =  (RB_roll_velocity  * (256 - (RB_ROLL_DAMPING +  tmp2/RB_DAMPFACTOR))/256 ) ;

		//dbg(tmp1/RB_DAMPFACTOR, tmp2/RB_DAMPFACTOR);

		
		//if(currSpeed > 0 ) dbg(RB_pitch_velocity, RB_roll_velocity);
		// Ensure that there is a minimal return to normal speed
		if (RB_pitch_velocity / 16 == 0) {
			//dbg(88888);
			RB_pitch_velocity = 1000;
			//if (RB_pitch > 0) RB_pitch_velocity = -1;
			//else RB_pitch_velocity = 1;
		}

		if (RB_roll_velocity/16 == 0) {
			//dbg(44444);
			RB_roll_velocity = 1000;
			//if (RB_roll > 0) RB_roll_velocity = -1;
			//else RB_roll_velocity = 1;
		}
		//dbg(torque_pitch, torque_roll, RB_pitch_velocity, RB_roll_velocity);

		//if(currSpeed > 0 ) dbg(torque_roll, RB_roll_velocity);
		// Update pitch and roll based on angular velocity
		RB_pitch = RB_pitch + RB_FRAMES * RB_pitch_velocity;
		RB_roll  = RB_roll  + RB_FRAMES * RB_roll_velocity;

		// Print debugging stuff:
		//get PRINT(RB_pitch, RB_roll, RB_pitch_velocity, RB_roll_velocity);
		//get PRINT(RB_pitch, RB_roll);

		// Execute corresponding movements
		#if (RB_FRAMES == 1)
			#if 0
			if (RB_pitch_velocity != 0) turn RB_BASE to x-axis RB_pitch now; 
			if (RB_roll_velocity  != 0) turn RB_BASE to z-axis RB_roll now; 
			#else
				if (RB_pitch_velocity != 0) turn RB_BASE to x-axis (RB_pitch/256) speed (30 * RB_pitch_velocity + 1);  
				if (RB_roll_velocity  != 0) turn RB_BASE to z-axis (RB_roll /256) speed (30 * RB_roll_velocity + 1); 
			#endif
		#else
			turn RB_BASE to x-axis RB_pitch speed (30 / RB_FRAMES) * RB_pitch_velocity;
			turn RB_BASE to z-axis RB_roll  speed (30 / RB_FRAMES) * RB_roll_velocity;
		#endif

		// increment bounce phase and modulo it
		if (currSpeed> 0){
			RB_bounce_frame = (RB_bounce_frame + RB_FRAMES * RB_BOUNCE_PERIOD);
			// emit a the bottom peak
			if (RB_bounce_frame >= <360>){
				RB_bounce_frame = 0;
				//dbg(RB_bounce_frame/ <1>,111);
			}

			// BowSplash Phase 1
			if (RB_bounce_frame >= RB_BOWSPLASH1_PHASE && RB_bounce_frame < RB_BOWSPLASH1_PHASE + (RB_FRAMES * RB_BOUNCE_PERIOD)){
				emit-sfx 1024 + 2 from bow;
			}

			// BowSplash Phase 2
			if (RB_bounce_frame >= RB_BOWSPLASH2_PHASE && RB_bounce_frame < RB_BOWSPLASH2_PHASE + (RB_FRAMES * RB_BOUNCE_PERIOD)){
				emit-sfx 1024 + 2 from bow;
			}
			
			//dbg(RB_bounce_frame/ <1>);
			// Calculate Bounce, be careful that your int doesnt overflow
			// Start at the -1 point of the cosine with + <180>
			cos_bounce = get KCOS(RB_bounce_frame + <180>) + 1024;

			//dbg(RB_bounce_frame/ <1>,cos_bounce);

			curr_bounce = RB_BOUNCE_HEIGHT * ((256 * currSpeed) / maxSpeed)/ 256;

			move RB_BASE to y-axis curr_bounce * cos_bounce / 1024 speed [500];
		}

		// emit a wakesplash on up and down bounce
		
		sleep 33 * RB_FRAMES - 1;
	}
}

// Pass in the pitch and heading of the current aiming here 
// heading: 0 is forward, 16K is 90deg left, -16K is 90 deg right
RecoilRockBoat(heading, power){
	// Separate heading into X and Z axes
	// Where RockZComponent is +1024 on the heading = left, RockXComponent is +1024 when aiming forward
	//get PRINT (heading,power, KSIN(heading), KCOS(heading));
	
	// Add with negative sign as we want it to move backwards from heading;
	
	RB_pitch_velocity = RB_pitch_velocity - (get KSIN(heading) * power) / RB_MASS;
	RB_roll_velocity  = RB_roll_velocity  - (get KCOS(heading) * power) / RB_MASS;
	
}

RockOnWaves()
{
	var currHeading, currSpeed, prevHeading_delta, prevSpeed_delta;	
	var maxSpeed;
	maxSpeed = get (MAX_SPEED);
	
	while( TRUE )
	{
		// get HEADINNG returns 0 when unit points South, 16K when unit points West, -16K when unit points East

		currSpeed =   get (CURRENT_SPEED);
		prevSpeed_delta = currSpeed - prevSpeed_delta;
		RB_pitch_target = -1 *( 200* prevSpeed_delta + currSpeed) / 200;
		
		currHeading = get (HEADING);
		prevHeading_delta = DELTAHEADING(currHeading, prevHeading_delta);
		RB_roll_target = (prevHeading_delta * currSpeed) / maxSpeed;
		
		//get PRINT(currHeading, currSpeed, prevHeading_delta, currHeading - prevHeading_delta);
		prevHeading_delta = currHeading;
		prevSpeed_delta = currSpeed;
		sleep 198;
	}
}


// anglez is left-right, +500 right
// anglex is front-back, where +500 is front

// only called if HitByWeaponId NOT defined
//HitByWeapon(anglex, anglez, damage)	// angle[x|z] is always [-500;500], damage is multiplied by 100
//{
//	get PRINT(-1000, anglex, anglez, damage);	
//}

// If HitByWeaponId is defined, then HitByWeapon is not called 
// anglez is left-right, +500 right
// anglex is front-back, where +500 is front

#define UNITSIZE (RB_LENGTH + RB_WIDTH)/2
#define MAXTILT 200

HitByWeaponId(anglex, anglez, weaponid, damage) //weaponID is always 0,lasers and flamers give angles of 0
{
	damage = damage / (100 * UNITSIZE);
	if (damage < 3  ) return (0);
	if (damage > MAXTILT) damage = MAXTILT;
	
	//get PRINT(anglex, anglez, weaponid, damage);
	RB_pitch_velocity = RB_pitch_velocity - (anglex * damage)  / 400 ;
	RB_roll_velocity  = RB_roll_velocity  + (anglez * damage)  / 400;
	// always return 100% damage!
	return (0); 
}

// -------------------------------- END WARSHIP --------------------

Create()
{
	hide bow;
	hide wake;
	hide flare2;
	hide flare3;
	hide flare1;
	hide aftflare;
	hide foreflare;
	hide ground;
	hide flare1;
	hide flare2;
	hide foreflare;
	hide aftflare;
	gun_1 = base;
	gun_2 = base;
	restore_delay = 3000;
	start-script InitRockBoat();
	SLEEP_UNTIL_UNITFINISHED;
	start-script BoatPhysics();
}

SetMaxReloadTime(reloadMS)
{
	restore_delay = reloadMS * 2;
}

static-var  Stunned;
ExecuteRestoreAfterDelay()
{
    if (Stunned) {
        return (1);
    }
	set-signal-mask 0;
	turn turret to y-axis <0.0> speed <55.0>;
	turn barrel1 to x-axis <0.0> speed <15.0>;
	turn barrel2 to x-axis <0.0> speed <15.0>;
}
SetStunned(State)
{
    Stunned = State;
	if (!Stunned) {
	    start-script ExecuteRestoreAfterDelay();
	}
}
RestoreAfterDelay()
{
	sleep restore_delay;
	start-script ExecuteRestoreAfterDelay();
}

RestoreDeckLaser()
{
	sleep 3000;
	set-signal-mask 0;
	turn foreturret to y-axis <0.0> speed <150.0>;
	turn foregun to x-axis <0.0> speed <100.0>;
	turn aftturret to y-axis <0.0> speed <150.0>;
	turn aftgun to x-axis <0.0> speed <100.0>;
}

waveSplash()
{
	return (0);
	while( TRUE )
	{
		turn base to x-axis <-3.0> speed <3.0>;
		move base to y-axis [0.32] speed [0.25];
		wait-for-turn base around x-axis;
		turn base to x-axis <0.0> speed <3.0>;
		move base to y-axis [0.0] speed [0.25];
		wait-for-turn base around x-axis;
	}
}

StartMoving(reversing)
{
	signal SIGNAL_MOVE;
	set-signal-mask SIGNAL_MOVE;
	var waketime;
	RB_bounce_frame = RAND(0, <180>);
	start-script waveSplash();
	var bowtime;
	bowtime = 0;
	while( TRUE )
	{
		//emit-sfx 1024 + 1 from wake;
		//if (bowtime) emit-sfx 1024 + 2 from bow;
        bowtime = !bowtime;
		waketime = (get CURRENT_SPEED) * 100 / get MAX_SPEED;
		if( waketime < 50 ) waketime = 50;
		sleep 10000 / waketime;
	}
}

StopMoving()
{
	signal SIGNAL_MOVE;
	turn base to x-axis <0.0> speed <3.0>;
	move base to y-axis [0.0] speed [0.25];
}

AimWeapon2(heading, pitch)
{
	signal SIGNAL_AIM2;
	set-signal-mask SIGNAL_AIM2;
	if( gun_2 )
	{
		turn aftturret to y-axis heading speed <300.0>;
		turn aftgun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn aftturret around y-axis;
		wait-for-turn aftgun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
	else
	{
		turn foreturret to y-axis heading speed <300.0>;
		turn foregun to x-axis <0.0> - pitch speed <200.0>;
		wait-for-turn foreturret around y-axis;
		wait-for-turn foregun around x-axis;
		start-script RestoreDeckLaser();
		return (1);
	}
}

FireWeapon2()
{
	gun_2 = !gun_2;
}

AimFromWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftgun;
	}
	else
	{
		pieceIndex = foregun;
	}
}

QueryWeapon2(pieceIndex)
{
	if( gun_2 )
	{
		pieceIndex = aftflare;
	}
	else
	{
		pieceIndex = foreflare;
	}
}

AimWeapon3(heading, pitch)
{
	aimDir3 = heading;
	return (1);
}

FireWeapon3()
{
	sleep 150;
	
	//call-script RecoilRockBoat(aimDir3, RB_RECOIL_ENERGY_3);
	RB_RECOILBOAT(aimDir3, RB_RECOIL_ENERGY_3);
}

AimFromWeapon3(pieceIndex)
{
	pieceIndex = base;
}

QueryWeapon3(pieceIndex)
{
	pieceIndex = base;
}

AimWeapon1(heading, pitch)
{
	signal SIGNAL_AIM1;
	set-signal-mask SIGNAL_AIM1;
	turn turret to y-axis heading speed <110.0>;
	turn sleeve to x-axis <0.0> - pitch speed <90.0>;
	wait-for-turn turret around y-axis;
	//wait-for-turn sleeve around x-axis;
	aimDir = heading;
	start-script RestoreAfterDelay();
	return (1);
}

FireWeapon1()
{
	//start-script RockZ(-7, aimDir);
	if( gun_1 ==0)
	{
	    emit-sfx 1024 + 0 from flare1;
		move barrel1 to z-axis [-2.300000] now;
		move barrel1 to z-axis [0.0] speed [1.500000];
	}
	else if (gun_1==1)
	{
	    emit-sfx 1024 + 0 from flare2;
		move barrel2 to z-axis [-2.300000] now;
		move barrel2 to z-axis [0.0] speed [1.500000];
	}else
	{
	    emit-sfx 1024 + 0 from flare3;
		move barrel3 to z-axis [-2.300000] now;
		move barrel3 to z-axis [0.0] speed [1.500000];
	}
	gun_1=gun_1+1;
	if (gun_1>2){
		gun_1=0;
	}
	
	// A bit of delay before adding velocity looks way better :D
	//#IF RB_FRAMES == 1
	//	sleep 65;
	//#ENDIF
	sleep 65 - 32 * RB_FRAMES;
	//call-script RecoilRockBoat(aimDir, RB_RECOIL_ENERGY_1);
	RB_RECOILBOAT(aimDir, RB_RECOIL_ENERGY_1);
}

AimFromWeapon1(pieceIndex)
{
	pieceIndex = turret;
}

QueryWeapon1(pieceIndex)
{
	if( gun_1 ==0)
	{
		pieceIndex = flare1;
	}
	else if( gun_1 ==1)
	{
		pieceIndex = flare2;
	}
	else
	{
		pieceIndex = flare3;
	}
}



Killed(severity, corpsetype)
{
	if( severity <= 25 )
	{
		corpsetype = 1 ;
		explode ground type BITMAPONLY | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type BITMAPONLY | NOHEATCLOUD;
		explode sleeve type BITMAPONLY | NOHEATCLOUD;
		explode barrel1 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 50 )
	{
		corpsetype = 2 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FALL | NOHEATCLOUD;
		explode barrel1 type FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	if( severity <= 99 )
	{
		corpsetype = 3 ;
		explode ground type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | SMOKE | FALL | NOHEATCLOUD;
		explode barrel3 type FIRE | SMOKE | FALL | NOHEATCLOUD;
		return(corpsetype);
	}
	corpsetype = 3 ;
		explode ground type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode base type BITMAPONLY | NOHEATCLOUD;
		explode turret type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode sleeve type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
		explode barrel1 type EXPLODE_ON_HIT | FIRE | FALL | NOHEATCLOUD;
		explode barrel3 type EXPLODE_ON_HIT | FIRE | SMOKE | FALL | NOHEATCLOUD;
	return corpsetype;
}
